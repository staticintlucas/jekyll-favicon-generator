# frozen_string_literal: true

require "vips"
require "bit-struct"

module JekyllFaviconGenerator
  module Ico
    # ICO file format references:
    # https://en.wikipedia.org/wiki/ICO_(file_format)
    # https://en.wikipedia.org/wiki/BMP_file_format
    # https://docs.microsoft.com/en-us/previous-versions/ms997538(v=msdn.10)
    # https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapinfoheader
    # Various ICO files from various websites and generated by other software

    extend self

    BYTE = 8
    WORD = 2 * BYTE
    DWORD = 4 * BYTE
    LONG = 4 * BYTE
    BPP_COUNT = 32

    def img_to_ico(src, ico, sizes)
      File.open(ico, "wb") do |f|
        f.write icon_dir sizes

        sizes.each do |width|
          height = width
          f.write bitmap_info_header width, height

          img = ::Vips::Image.thumbnail src, width, :height => height
          img = img.flip(:vertical) # Flip the image since bitmap is stored bottom to top
          img = img.colourspace :srgb # Ensure srgb colourspace
          f.write bitmap_xor_mask img, width, height
          f.write bitmap_and_mask img, width, height
        end
      end
      true
    end

    private

    # Generate the ICONDIR structure for the ICO file
    def icon_dir(sizes)
      count = sizes.length
      offset = IconDir.round_byte_length + count * IconDirEntry.round_byte_length

      dir = IconDir.new.tap do |id|
        id.type     = 1 # 1 => ICO
        id.id_count = count
      end.to_s

      entries = sizes.map do |size|
        entry = icon_dir_entry size, offset
        offset += entry.bytes_in_res
        entry.to_s
      end

      dir + entries.join
    end

    def icon_dir_entry(size, offset)
      xor_rowsize = rowsize size * BPP_COUNT
      and_rowsize = rowsize size
      bytes = BitMapInfoHeader.round_byte_length + xor_rowsize * size + and_rowsize * size

      IconDirEntry.new.tap do |ide|
        ide.width         = size
        ide.height        = size
        ide.color_count   = 0 # 0 => no color palette
        ide.planes        = 1
        ide.bit_count     = BPP_COUNT
        ide.bytes_in_res  = bytes
        ide.image_offset  = offset
      end
    end

    def bitmap_info_header(width, height)
      BitMapInfoHeader.new.tap do |bih|
        bih.ih_size     = BitMapInfoHeader.round_byte_length # size is only the header size
        bih.width       = width
        bih.height      = 2 * height # must be double height, even if no AND mask is included
        bih.planes      = 1
        bih.bit_count   = BPP_COUNT
        bih.compression = 0 # 0 => none
        bih.size_image  = width * height * BPP_COUNT / BYTE
        bih.clr_used    = 0 # 0 since we don't use a palette
      end
    end

    def bitmap_xor_mask(img, width, _height)
      xor_rowsize = rowsize(width * BPP_COUNT)
      arr = img.to_enum.map do |row|
        # Colors are stored in ARGB format with LE order, so BGRA in the array
        # Also pad rows to the required size
        row.map { |r, g, b, a| [b, g, r, a] }.fill([0, 0, 0, 0], row.length..(xor_rowsize / 4 - 1))
      end
      arr.flatten.pack("C*")
    end

    def bitmap_and_mask(img, width, _height)
      and_rowsize = rowsize width
      arr = img.to_enum.map do |row|
        # Convert alpha to 1-bit and pad rows to the required size
        row.map { |_r, _g, _b, a| a.zero? && 1 || 0 }.fill(0, row.length..(and_rowsize * BYTE - 1))
      end
      [arr.flatten.join].pack("B*")
    end

    # Given a size in bits, return the size in bytes, rounded up to a multiple of 4 bytes
    def rowsize(bit_size)
      (bit_size + 31) / 32 * 4
    end

    class IconDir < BitStruct
      default_options :endian => :little

      pad      :reserved, WORD
      unsigned :type,     WORD
      unsigned :id_count, WORD
    end

    class IconDirEntry < BitStruct
      default_options :endian => :little

      unsigned :width,        BYTE
      unsigned :height,       BYTE
      unsigned :color_count,  BYTE
      pad      :reserved,     BYTE
      unsigned :planes,       WORD
      unsigned :bit_count,    WORD
      unsigned :bytes_in_res, DWORD
      unsigned :image_offset, DWORD
    end

    class BitMapInfoHeader < BitStruct
      default_options :endian => :little

      unsigned :ih_size,          DWORD
      signed   :width,            LONG
      signed   :height,           LONG
      unsigned :planes,           WORD
      unsigned :bit_count,        WORD
      unsigned :compression,      DWORD
      unsigned :size_image,       DWORD
      signed   :x_pels_per_meter, LONG, :default => 3780 # 96 dpi (usually ignored)
      signed   :y_pels_per_meter, LONG, :default => 3780 # 96 dpi (usually ignored)
      unsigned :clr_used,         DWORD
      unsigned :clr_important,    DWORD, :default => 0  # 0 important colours (usually ignored)
    end
  end
end
